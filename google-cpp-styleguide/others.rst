6. 其他特性
----------------------------

6.1. 前置自增和自减
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. tip::

    当表达式的值未被使用时, 传统的做法是使用后置自增, 特别是在 ``for`` 循环中. 因为这很像自然语言, 主语 (``i``) 在谓语动词 (``++``) 前.

定义:

    对于变量在自增 (``++i`` 或 ``i++``) 或自减 (``--i`` 或 ``i--``) 后表达式的值又没有没用到的情况下, 需要确定到底是使用前置还是后置的自增 (自减).

优点:

    不考虑返回值的话, 前置自增 (``++i``) 通常要比后置自增 (``i++``) 效率更高. 因为后置自增 (或自减) 需要对表达式的值 ``i`` 进行一次拷贝.


6.2. ``const`` 用法
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. tip::

    我们强烈建议你在任何可能的情况下都要使用 ``const``.

定义:

    在声明的变量或参数前加上关键字 ``const`` 用于指明变量值不可被篡改 (如 ``const int foo`` ).

优点:

    大家更容易理解如何使用变量. 编译器可以更好地进行类型检测, 相应地, 也能生成更好的代码. 人们对编写正确的代码更加自信, 因为他们知道所调用的函数被限定了能或不能修改变量值. 即使是在无锁的多线程编程中, 人们也知道什么样的函数是安全的.

缺点:

    ``const`` 是入侵性的: 如果你向一个函数传入 ``const`` 变量, 函数原型声明中也必须对应 ``const`` 参数, 在调用库函数时显得尤其麻烦.

结论:

    ``const`` 变量, 数据成员, 函数和参数为编译时类型检测增加了一层保障; 便于尽早发现错误. 因此, 我们强烈建议在任何可能的情况下使用 ``const``:

        - 如果函数不会修改你传入的指针类型参数, 该参数应声明为 ``const``.
        - 如果数据成员在对象构造之后不再发生变化, 可将其定义为 ``const``.

    然而, 也不要发了疯似的使用 ``const``. 像 ``const int * const * const x;`` 就有些过了, 虽然它非常精确的描述了常量 ``x``. 关注真正有帮助意义的信息: 前面的例子写成 ``const int **x`` 就够了.

``const`` 的位置:

    有人喜欢 ``int const *foo`` 形式, 不喜欢 ``const int* foo``, 他们认为前者更一致因此可读性也更好: 遵循了 ``const`` 总位于其描述的对象之后的原则. 但是一致性原则不适用于此, "不要过度使用" 的声明可以取消大部分你原本想保持的一致性. 将 ``const`` 放在前面才更易读, 因为在自然语言中形容词 (``const``) 是在名词 (``int``) 之前.

    这是说, 我们提倡但不强制 ``const`` 在前. 但要保持代码的一致性! (Yang.Y 注: 也就是不要在一些地方把 ``const`` 写在类型前面, 在其他地方又写在后面, 确定一种写法, 然后保持一致.)

6.3. 整型
~~~~~~~~~~~~~~~~~~

.. tip::

    C/C++ 内建整型中, 仅使用 ``int``. 如果程序中需要不同大小的变量, 可以使用 ``<stdint.h>`` 中长度精确的整型, 如 ``int16_t``.如果您的变量可能不小于 2^31 (2GiB), 就用 64 位变量比如 ``int64_t``. 此外要留意，哪怕您的值并不会超出 int 所能够表示的范围，在计算过程中也可能会溢出。所以拿不准时，干脆用更大的类型。

定义:

    C/C++ 没有指定整型的大小. 通常人们假定 ``short`` 是 16 位, ``int`` 是 32 位, ``long`` 是 32 位, ``long long`` 是 64 位.

优点:

    保持声明统一.

缺点:

    C/C++ 中整型大小因编译器和体系结构的不同而不同.

结论:

    ``<stdint.h>`` 定义了 ``int16_t``, ``uint32_t``, ``int64_t`` 等整型, 在需要确保整型大小时可以使用它们代替 ``short``, ``unsigned long long`` 等. 在 C 整型中, 只使用 ``int``. 在合适的情况下, 推荐使用标准类型如 ``size_t`` 和 ``ptrdiff_t``.

    如果已知整数不会太大, 我们常常会使用 ``int``, 如循环计数. 在类似的情况下使用原生类型 ``int``. 你可以认为 ``int`` 至少为 32 位, 但不要认为它会多于 ``32`` 位. 如果需要 64 位整型, 用 ``int64_t`` 或 ``uint64_t``.

    对于大整数, 使用 ``int64_t``.

    不要使用 ``uint32_t`` 等无符号整型, 除非你是在表示一个位组而不是一个数值, 或是你需要定义二进制补码溢出. 尤其是不要为了指出数值永不会为负, 而使用无符号类型. 相反, 你应该使用断言来保护数据.

    小心整型类型转换和整型提升（acgtyrant 注：integer promotions, 比如 ``int`` 与 ``unsigned int`` 运算时，前者被提升为 ``unsigned int`` 而有可能溢出），总有意想不到的后果。

关于无符号整数:

    有些人, 包括一些教科书作者, 推荐使用无符号类型表示非负数. 这种做法试图达到自我文档化. 但是, 在 C 语言中, 这一优点被由其导致的 bug 所淹没. 看看下面的例子:

        .. code-block:: c

            for (unsigned int i = length-1; i >= 0; --i) ...

    上述循环永远不会退出! 有时 gcc 会发现该 bug 并报警, 但大部分情况下都不会. 类似的 bug 还会出现在比较有符合变量和无符号变量时. 主要是 C 的类型提升机制会致使无符号类型的行为出乎你的意料.

    因此, 使用断言来指出变量为非负数, 而不是使用无符号型!

6.4. 64 位下的可移植性
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. tip::

    代码应该对 64 位和 32 位系统友好. 处理打印, 比较, 结构体对齐时应切记:

- 对于某些类型, ``printf()`` 的指示符在 32 位和 64 位系统上可移植性不是很好. C99 标准定义了一些可移植的格式化指示符. 不幸的是, MSVC 7.1 并非全部支持, 而且标准中也有所遗漏, 所以有时我们不得不自己定义一个丑陋的版本 (头文件 ``inttypes.h`` 仿标准风格):

    .. code-block:: c

        // printf macros for size_t, in the style of inttypes.h
        #ifdef _LP64
        #define __PRIS_PREFIX "z"
        #else
        #define __PRIS_PREFIX
        #endif

        // Use these macros after a % in a printf format string
        // to get correct 32/64 bit behavior, like this:
        // size_t size = records.size();
        // printf("%"PRIuS"\n", size);
        #define PRIdS __PRIS_PREFIX "d"
        #define PRIxS __PRIS_PREFIX "x"
        #define PRIuS __PRIS_PREFIX "u"
        #define PRIXS __PRIS_PREFIX "X"
        #define PRIoS __PRIS_PREFIX "o"


    +-------------------+---------------------+--------------------------+------------------+
    | 类型              | 不要使用            | 使用                     | 备注             |
    +===================+=====================+==========================+==================+
    | ``void *``        |                     |                          |                  |
    | (或其他指针类型)  | ``%lx``             | ``%p``                   |                  |
    +-------------------+---------------------+--------------------------+------------------+
    | ``int64_t``       | ``%qd, %lld``       | ``%"PRId64"``            |                  |
    +-------------------+---------------------+--------------------------+------------------+
    | ``uint64_t``      | ``%qu, %llu, %llx`` | ``%"PRIu64", %"PRIx64"`` |                  |
    +-------------------+---------------------+--------------------------+------------------+
    | ``size_t``        | ``%u``              | ``%"PRIuS", %"PRIxS"``   | C99 规定 ``%zu`` |
    +-------------------+---------------------+--------------------------+------------------+
    | ``ptrdiff_t``     | ``%d``              | ``%"PRIdS"``             | C99 规定 ``%zd`` |
    +-------------------+---------------------+--------------------------+------------------+

    注意 ``PRI*`` 宏会被编译器扩展为独立字符串. 因此如果使用非常量的格式化字符串, 需要将宏的值而不是宏名插入格式中. 使用 ``PRI*`` 宏同样可以在 ``%`` 后包含长度指示符. 例如, ``printf("x = %30"PRIuS"\n", x)`` 在 32 位 Linux 上将被展开为 ``printf("x = %30" "u" "\n", x)``, 编译器当成 ``printf("x = %30u\n", x)`` 处理 (Yang.Y 注: 这在 MSVC 6.0 上行不通, VC 6 编译器不会自动把引号间隔的多个字符串连接一个长字符串).

- 记住 ``sizeof(void *) != sizeof(int)``. 如果需要一个指针大小的整数要用 ``intptr_t``.

- 你要非常小心的对待结构体对齐, 尤其是要持久化到磁盘上的结构体 (Yang.Y 注: 持久化 - 将数据按字节流顺序保存在磁盘文件或数据库中). 在 64 位系统中, 任何含有 ``int64_t``/``uint64_t`` 成员的类/结构体, 缺省都以 8 字节在结尾对齐. 如果 32 位和 64 位代码要共用持久化的结构体, 需要确保两种体系结构下的结构体对齐一致. 大多数编译器都允许调整结构体对齐. gcc 中可使用 ``__attribute__((packed))``. MSVC 则提供了 ``#pragma pack()`` 和 ``__declspec(align())`` (YuleFox 注, 解决方案的项目属性里也可以直接设置).

- 创建 64 位常量时使用 LL 或 ULL 作为后缀, 如:

    .. code-block:: c

        int64_t my_value = 0x123456789LL;
        uint64_t my_mask = 3ULL << 48;


- 如果你确实需要 32 位和 64 位系统具有不同代码, 可以使用 ``#ifdef _LP64`` 指令来切分 32/64 位代码. (尽量不要这么做, 如果非用不可, 尽量使修改局部化)

.. _preprocessor-macros:

6.5. 预处理宏
~~~~~~~~~~~~~~~~~~~~~~~~

.. tip::

    使用宏时要非常谨慎, 尽量以内联函数, 枚举和常量代替之.

宏意味着你和编译器看到的代码是不同的. 这可能会导致异常行为, 尤其因为宏具有全局作用域.

以往用宏展开性能关键的代码, 现在可以用内联函数替代. 用宏表示常量可被 ``const`` 变量代替. 用宏进行条件编译... 这个, 千万别这么做, 会令测试更加痛苦 (``#define`` 防止头文件重包含当然是个特例).

宏可以做一些其他技术无法实现的事情, 在一些代码库 (尤其是底层库中) 可以看到宏的某些特性 (如用 ``#`` 字符串化, 用 ``##`` 连接等等). 但在使用前, 仔细考虑一下能不能不使用宏达到同样的目的.

下面给出的用法模式可以避免使用宏带来的问题; 如果你要宏, 尽可能遵守:

    - 尽量不要在 ``.h`` 文件中定义宏.
    - 在马上要使用时才进行 ``#define``, 使用后要立即 ``#undef``.
    - 不要只是对已经存在的宏使用#undef，选择一个不会冲突的名称；

6.6. 0 和 ``NULL``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. tip::

    整数用 ``0``, 实数用 ``0.0``, 指针用 ``NULL``, 字符 (串) 用 ``'\0'``.

    整数用 ``0``, 实数用 ``0.0``, 这一点是毫无争议的.

    对于指针 (地址值), 到底是用 ``0``, 还是 ``NULL``. 实际上，一些编译器对 ``NULL`` 的定义比较特殊，可以输出有用的警告，特别是 ``sizeof(NULL)`` 就和 ``sizeof(0)`` 不一样。

    字符 (串) 用 ``'\0'``, 不仅类型正确而且可读性好.

6.7. sizeof
~~~~~~~~~~~~~~~~~~~~~~~~

.. tip::

    尽可能用 ``sizeof(varname)`` 代替 ``sizeof(type)``.

    使用 ``sizeof(varname)`` 是因为当代码中变量类型改变时会自动更新. 您或许会用 ``sizeof(type)`` 处理不涉及任何变量的代码，比如处理来自外部或内部的数据格式，这时用变量就不合适了。

    .. code-block:: c

        Struct data;
        Struct data; memset(&data, 0, sizeof(data));

    .. warning::
        .. code-block:: c

            memset(&data, 0, sizeof(Struct));

    .. code-block:: c

        if (raw_size < sizeof(int)) {
            LOG(ERROR) << "compressed record not big enough for count: " << raw_size;
            return false;
        }


译者（acgtyrant）笔记
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#. 注意初始化 const 对象时，必须在初始化的同时值初始化。
#. 用断言代替无符号整型类型，深有启发。

